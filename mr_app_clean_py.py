# -*- coding: utf-8 -*-
"""mr_app_clean.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yANahM3gk_dZZcTeZEL1KekOpksIsFB-
"""

from flask import Flask, request, render_template
import requests
import random
import spacy
from datetime import datetime
import os

# Load spaCy model
nlp = spacy.load("en_core_web_md")

# Initialize Flask app
app = Flask(__name__, template_folder='templates')  # Use relative path for templates

# TMDb API Key and Base URL
API_KEY = '067fd28c11279efc124bd66dcee5a58d'
BASE_URL = 'https://api.themoviedb.org/3'

# Expanded mood-to-genre mapping
mood_genre_mapping = {
    'happy': 35,
    'thrilled': 53,
    'thoughtful': 18,
    'adventurous': 12,
    'sad': 18,
    'melancholy': 18,
    'excited': 28,
    'calm': 10751,
    'scared': 27,
    'romantic': 10749,
    'dramatic': 18,
    'funny': 35,
    'inspired': 18
}

# Find the closest mood based on similarity
def find_closest_mood(user_mood):
    user_mood_doc = nlp(user_mood)
    closest_mood = None
    highest_similarity = -1

    for mood in mood_genre_mapping.keys():
        mood_doc = nlp(mood)
        similarity = user_mood_doc.similarity(mood_doc)

        if similarity > highest_similarity:
            closest_mood = mood
            highest_similarity = similarity

    if highest_similarity < 0.5:
        closest_mood = 'thoughtful'

    return closest_mood

# Get detailed movie info including trailer, cast, runtime, and streaming services
def get_movie_details(movie_id, country_code='US'):
    url = f"{BASE_URL}/movie/{movie_id}"
    params = {'api_key': API_KEY, 'append_to_response': 'videos,credits,watch/providers'}
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        trailer_url = next((f"https://www.youtube.com/watch?v={video['key']}" for video in data['videos']['results']
                            if video['type'] == 'Trailer' and video['site'] == 'YouTube'), None)
        cast = ', '.join([member['name'] for member in data['credits']['cast'][:5]])
        providers = data['watch/providers']['results'].get(country_code, {})
        streaming_services = ', '.join([provider['provider_name'] for provider in providers.get('flatrate', [])])
        return {
            'title': data['title'],
            'release_date': data.get('release_date', 'N/A'),
            'vote_average': data['vote_average'],
            'runtime': data.get('runtime', 'N/A'),
            'trailer_url': trailer_url,
            'cast': cast,
            'streaming_services': streaming_services or 'Not available for streaming'
        }
    return None

# Get movies from TMDB API based on genre, runtime, and other filters
def get_tmdb_movies(genre_id, min_runtime, max_runtime, language, year_min=None, year_max=None):
    url = f"{BASE_URL}/discover/movie"
    params = {
        'api_key': API_KEY,
        'with_genres': genre_id,
        'with_original_language': language,
        'with_runtime.gte': min_runtime,
        'with_runtime.lte': max_runtime,
        'sort_by': 'popularity.desc',
        'vote_average.gte': 5,
        'include_adult': False,
    }
    if year_min:
        params['primary_release_date.gte'] = f"{year_min}-01-01"
    if year_max:
        params['primary_release_date.lte'] = f"{year_max}-12-31"

    response = requests.get(url, params=params)
    if response.status_code == 200:
        movies = response.json().get('results', [])
        return [get_movie_details(movie['id']) for movie in movies if get_movie_details(movie['id']) is not None]
    return []

# Define route for the homepage
@app.route('/')
def home():
    return render_template('home.html')

# Define route for displaying recommendations
@app.route('/recommend', methods=['POST'])
def recommend():
    user_mood = request.form.get('mood').strip().lower()
    time_available = int(request.form.get('time_available').strip())
    streaming_services = request.form.getlist('streaming_services')

    closest_mood = find_closest_mood(user_mood)
    genre_id = mood_genre_mapping.get(closest_mood, 18)

    min_runtime = max(0, time_available - 20)
    max_runtime = time_available
    current_year = datetime.now().year

    # Fetch movies based on criteria
    recent_movies = get_tmdb_movies(genre_id, min_runtime, max_runtime, language='en', year_min=current_year - 10, year_max=current_year)
    older_movies = get_tmdb_movies(genre_id, min_runtime, max_runtime, language='en', year_max=current_year - 10)

    recommendations = [
        (random.choice([movie for movie in recent_movies if movie and any(service in movie['streaming_services'] for service in streaming_services)]), "Recent Movie (within last 10 years)"),
        (random.choice([movie for movie in older_movies if movie and any(service in movie['streaming_services'] for service in streaming_services)]), "Older Movie (more than 10 years old)")
    ]

    return render_template('recommendations.html', mood=closest_mood.capitalize(), recommendations=recommendations)

if __name__ == '__main__':
    app.run()