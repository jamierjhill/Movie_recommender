# -*- coding: utf-8 -*-
"""mr_app_clean.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yANahM3gk_dZZcTeZEL1KekOpksIsFB-
"""

from flask import Flask, request, render_template
import requests
import random
from datetime import datetime

# Initialize Flask app
app = Flask(__name__, template_folder='templates')

# TMDb API Key and Base URL
API_KEY = '067fd28c11279efc124bd66dcee5a58d'
BASE_URL = 'https://api.themoviedb.org/3'

# Expanded genre mapping (no longer based on moods)
genre_mapping = {
    'comedy': 35,
    'thriller': 53,
    'drama': 18,
    'adventure': 12,
    'family': 10751,
    'horror': 27,
    'romance': 10749,
    'action': 28,
    'documentary': 99,
    'mystery': 9648,
    'fantasy': 14,
    'animation': 16,
    'music': 10402,
    'crime': 80,
    'science fiction': 878,
    'history': 36,
    'tv movie': 10770
}

# Get detailed movie info including trailer, cast, runtime, and streaming services
def get_movie_details(movie_id, country_code='US'):
    url = f"{BASE_URL}/movie/{movie_id}"
    params = {'api_key': API_KEY, 'append_to_response': 'videos,credits,watch/providers'}
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        trailer_url = next((f"https://www.youtube.com/watch?v={video['key']}" for video in data['videos']['results']
                            if video['type'] == 'Trailer' and video['site'] == 'YouTube'), None)
        cast = ', '.join([member['name'] for member in data['credits']['cast'][:5]])
        providers = data['watch/providers']['results'].get(country_code, {})
        streaming_services = ', '.join([provider['provider_name'] for provider in providers.get('flatrate', [])])
        return {
            'title': data['title'],
            'release_date': data.get('release_date', 'N/A'),
            'vote_average': data['vote_average'],
            'runtime': data.get('runtime', 'N/A'),
            'trailer_url': trailer_url,
            'cast': cast,
            'streaming_services': streaming_services or 'Not available for streaming'
        }
    return None

# Get movies from TMDB API based on genre, runtime, and other filters
def get_tmdb_movies(genre_id, min_runtime, max_runtime, language, year_min=None, year_max=None):
    url = f"{BASE_URL}/discover/movie"
    params = {
        'api_key': API_KEY,
        'with_genres': genre_id,
        'with_original_language': language,
        'with_runtime.gte': min_runtime,
        'with_runtime.lte': max_runtime,
        'sort_by': 'popularity.desc',
        'vote_average.gte': 5,
        'include_adult': False,
    }
    if year_min:
        params['primary_release_date.gte'] = f"{year_min}-01-01"
    if year_max:
        params['primary_release_date.lte'] = f"{year_max}-12-31"

    response = requests.get(url, params=params)
    if response.status_code == 200:
        movies = response.json().get('results', [])
        return [get_movie_details(movie['id']) for movie in movies if get_movie_details(movie['id']) is not None]
    return []

# Define route for the homepage
@app.route('/')
def home():
    return render_template('home.html')

# Define route for displaying recommendations
@app.route('/recommend', methods=['POST'])
def recommend():
    user_genre = request.form.get('genre').strip().lower()
    time_available = int(request.form.get('time_available').strip())
    streaming_services = request.form.getlist('streaming_services')

    # Get genre ID directly from the input
    genre_id = genre_mapping.get(user_genre)
    if not genre_id:
        return "Genre not found. Please enter a valid genre.", 400

    min_runtime = max(0, time_available - 20)
    max_runtime = time_available
    current_year = datetime.now().year

    # Fetch movies based on criteria
    recent_movies = get_tmdb_movies(genre_id, min_runtime, max_runtime, language='en', year_min=current_year - 10, year_max=current_year)
    older_movies = get_tmdb_movies(genre_id, min_runtime, max_runtime, language='en', year_max=current_year - 10)

    recommendations = [
        (random.choice([movie for movie in recent_movies if movie and any(service in movie['streaming_services'] for service in streaming_services)]), "Recent Movie (within last 10 years)"),
        (random.choice([movie for movie in older_movies if movie and any(service in movie['streaming_services'] for service in streaming_services)]), "Older Movie (more than 10 years old)")
    ]

    return render_template('recommendations.html', genre=user_genre.capitalize(), recommendations=recommendations)

if __name__ == '__main__':
    app.run()